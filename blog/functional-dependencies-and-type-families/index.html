<!doctype html><html lang=en-us data-theme=light><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel=icon href=https://gvolpe.com/images/favicon.png><title>Functional Dependencies & Type Families - Gabriel Volpe</title><meta name=description content="In the past few months I have learnt a lot! Probably the coolest stuff has been about Functional Dependencies and Type Families, so this is my attempt to ‚Ä¶"><meta property="og:title" content="Functional Dependencies & Type Families"><meta property="og:description" content="In the past few months I have learnt a lot! Probably the coolest stuff has been about Functional Dependencies and Type Families, so this is my attempt to ‚Ä¶"><meta property="og:type" content="article"><meta property="og:url" content="https://gvolpe.com/blog/functional-dependencies-and-type-families/"><meta property="og:site_name" content="Gabriel Volpe"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="Functional Dependencies & Type Families"><meta name=twitter:description content="In the past few months I have learnt a lot! Probably the coolest stuff has been about Functional Dependencies and Type Families, so this is my attempt to ‚Ä¶"><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Orbitron:wght@400;700&family=JetBrains+Mono:wght@400;500&display=swap" rel=stylesheet><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css><link rel=stylesheet href=https://gvolpe.com/css/style.css><script type=text/javascript defer data-domain=gvolpe.com src=https://gvolpe.com/js/plausible.js></script></head><body><main><div id=post-overlay-id class="post-overlay active"><div class=reading-progress></div><div class=post-overlay-backdrop></div><div id=post-overlay-content-id class=post-overlay-content style=position:relative;min-height:100vh;padding:0;transform:translateY(0)><div class=post-overlay-header><div class=post-overlay-title><a href=/ class=overlay-site-title>Gabriel Volpe</a></div><button class=post-overlay-close aria-label="Close post" onclick='window.location.href="/"'>
<i class="fas fa-times"></i></button></div><div class=post-layout><article class=post-content><header class=post-header><div class=post-meta><span class=post-date>2019.08.27</span><div class=reading-time-post><span class=coffee-cups>üìöüìöüìöüìöüìö
</span><span>6 min read</span></div></div><h1 class=post-title>Functional Dependencies & Type Families</h1><div class=post-tags-header><a href=https://gvolpe.com/tags/haskell class=post-tag>haskell</a></div></header><div class=post-body><p>In the past few months I have learnt a lot! Probably the coolest stuff has been about <a href=https://wiki.haskell.org/Functional_dependencies>Functional Dependencies</a> and <a href=https://wiki.haskell.org/GHC/Type_families>Type Families</a>, so this is my attempt to explain it in order to gain a better understanding and hopefully help someone else out there as well.</p><p>So please be kind if you see any mistake, let me know and I&rsquo;ll try to fix it üôÇ</p><h3 id=a-motivating-example>A motivating example</h3><p>One of the fun applications I&rsquo;ve worked on is <a href=https://github.com/gvolpe/exchange-rates>exchange-rates</a>, which uses the <a href=https://www.fpcomplete.com/blog/2017/07/the-rio-monad>RIO Monad</a> (basically <code>ReaderT</code> + <code>IO</code>).</p><p>When defining dependencies using such effect is very common to do it using the <a href=https://www.fpcomplete.com/blog/2017/06/readert-design-pattern>Has typeclass approach</a> (or how I prefer to call it, the <em>classy lenses Has pattern</em>) instead of passing the whole context / environment.</p><p>Following this approach, I have defined a polymorphic <code>Ctx</code> record that represents the application context (or dependencies). It looks as follows:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#66d9ef>data</span> <span style=color:#66d9ef>Ctx</span> m <span style=color:#f92672>=</span> <span style=color:#66d9ef>Ctx</span>
</span></span><span style=display:flex><span>  { ctxLogger <span style=color:#f92672>::</span> <span style=color:#66d9ef>Logger</span> m
</span></span><span style=display:flex><span>  , ctxCache <span style=color:#f92672>::</span> <span style=color:#66d9ef>Cache</span> m
</span></span><span style=display:flex><span>  , ctxForexClient <span style=color:#f92672>::</span> <span style=color:#66d9ef>ForexClient</span> m
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><p>If we continue with the <code>Has</code> approach we would get something like this for our <code>Logger m</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#66d9ef>HasLogger</span> ctx <span style=color:#66d9ef>where</span>
</span></span><span style=display:flex><span>  loggerL <span style=color:#f92672>::</span> <span style=color:#66d9ef>Lens&#39;</span> ctx (<span style=color:#66d9ef>Logger</span> m)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>instance</span> <span style=color:#66d9ef>HasLogger</span> (<span style=color:#66d9ef>Ctx</span> m) <span style=color:#66d9ef>where</span>
</span></span><span style=display:flex><span>  loggerL <span style=color:#f92672>=</span> lens ctxLogger (<span style=color:#a6e22e>\</span>x y <span style=color:#f92672>-&gt;</span> x { ctxLogger <span style=color:#f92672>=</span> y })
</span></span></code></pre></div><p>But&mldr; Oops, it doesn&rsquo;t compile!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>Couldn<span style=color:#e6db74>&#39;t match type ‚Äòm1‚Äô with ‚Äòm‚Äô
</span></span></span><span style=display:flex><span><span style=color:#e6db74>      ‚Äòm1‚Äô is a rigid type variable bound by
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        the type signature for:
</span></span></span><span style=display:flex><span><span style=color:#e6db74>          loggerL :: forall (m1 :: * -&gt; *). Lens&#39;</span> <span style=color:#f92672>(</span>Ctx m<span style=color:#f92672>)</span> <span style=color:#f92672>(</span>Logger m1<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>        at src/Context.hs:27:3-9
</span></span><span style=display:flex><span>      ‚Äòm‚Äô is a rigid type variable bound by
</span></span><span style=display:flex><span>        the instance declaration
</span></span><span style=display:flex><span>        at src/Context.hs:26:10-47
</span></span></code></pre></div><p>The reason is that the compiler has no way to know that the <code>m</code> in <code>Logger m</code> (declared in the type class) is the same as the <code>m</code> in <code>Ctx m</code> (declared in the instance), therefore the inferred type ends up being <code>Lens' (Ctx m) (Logger m1)</code>.</p><h3 id=functional-dependencies-to-the-rescue>Functional Dependencies to the rescue</h3><p>We can fix it by introducing a language extension named <a href=https://wiki.haskell.org/Functional_dependencies>FunctionalDependencies</a>, introduced in the paper <a href=https://web.cecs.pdx.edu/~mpj/pubs/fundeps-esop2000.pdf>Type Classes with Functional Dependencies</a> by Mark P. Jones in March 2000.</p><p>We need to change our type class definition as below:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#75715e>{-# LANGUAGE FlexibleInstances      #-}</span>
</span></span><span style=display:flex><span><span style=color:#75715e>{-# LANGUAGE FunctionalDependencies #-}</span>
</span></span><span style=display:flex><span><span style=color:#75715e>{-# LANGUAGE MultiParamTypeClasses  #-}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#66d9ef>HasLogger</span> ctx m <span style=color:#f92672>|</span> ctx <span style=color:#f92672>-&gt;</span> m <span style=color:#66d9ef>where</span>
</span></span><span style=display:flex><span>  loggerL <span style=color:#f92672>::</span> <span style=color:#66d9ef>Lens&#39;</span> ctx (<span style=color:#66d9ef>Logger</span> m)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>instance</span> <span style=color:#66d9ef>HasLogger</span> (<span style=color:#66d9ef>Ctx</span> m) m <span style=color:#66d9ef>where</span>
</span></span><span style=display:flex><span>  loggerL <span style=color:#f92672>=</span> lens ctxLogger (<span style=color:#a6e22e>\</span>x y <span style=color:#f92672>-&gt;</span> x { ctxLogger <span style=color:#f92672>=</span> y })
</span></span></code></pre></div><p>Our type class has now two parameters, <code>ctx</code> and <code>m</code>, and in addition we define a <em>functional dependency</em> <code>ctx -> m</code>. This means that <code>ctx</code> uniquely determines the type of <code>m</code>, which constraints the possible instances and helps with type
inference.</p><style>.quote::before{content:"‚ÑπÔ∏è"}</style><div class=quote><h4>Attention</h4><p>Notice the extensions we had to enable to make this compile.</p></div><h4 id=arithmetic-example>Arithmetic example</h4><p>Here&rsquo;s another example taken from the <a href=http://www.cse.chalmers.se/~hallgren/Papers/hallgren.pdf>Fun with Functional Dependencies</a> paper by Thomas Hallgren. What&rsquo;s simpler than adding two values together?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#66d9ef>Add</span> a b c <span style=color:#f92672>|</span> a b <span style=color:#f92672>-&gt;</span> c <span style=color:#66d9ef>where</span>
</span></span><span style=display:flex><span>  add <span style=color:#f92672>::</span> a <span style=color:#f92672>-&gt;</span> b <span style=color:#f92672>-&gt;</span> c
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>instance</span> <span style=color:#66d9ef>Add</span> <span style=color:#66d9ef>Zero</span> b b
</span></span><span style=display:flex><span><span style=color:#66d9ef>instance</span> <span style=color:#66d9ef>Add</span> a b c <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>Add</span> (<span style=color:#66d9ef>Succ</span> a) b (<span style=color:#66d9ef>Succ</span> c)
</span></span></code></pre></div><p>The functional dependency is pretty clear: given <code>a</code> and <code>b</code> we can add them together and produce <code>c</code>. So <code>a</code> and
<code>b</code> uniquely determine <code>c</code>.</p><p>Notice how we don&rsquo;t even need to define <code>add</code>, specifying the types is enough! If it&rsquo;s still not clear, bear with me and let&rsquo;s perform type substitution step by step (feel free to skip this part):</p><p>Given this instance, all we are saying is that:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#66d9ef>instance</span> <span style=color:#66d9ef>Add</span> <span style=color:#66d9ef>Zero</span> b b <span style=color:#66d9ef>where</span>
</span></span></code></pre></div><ul><li><code>a</code> is defined as <code>Zero</code>.</li><li><code>b</code> is defined as <code>b</code>.</li><li><code>c</code> is defined as <code>b</code>.</li></ul><p>Since we now know the types of <code>a</code>, <code>b</code> and <code>c</code>, defining the <code>add</code> function becomes redundant:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#66d9ef>instance</span> <span style=color:#66d9ef>Add</span> <span style=color:#66d9ef>Zero</span> b b <span style=color:#66d9ef>where</span>
</span></span><span style=display:flex><span>  add <span style=color:#66d9ef>Zero</span> b <span style=color:#f92672>=</span> b
</span></span></code></pre></div><p>Clear now? Awesome! Let&rsquo;s try this out in the REPL:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#a6e22e>Œª</span> <span style=color:#66d9ef>:</span>t add (u<span style=color:#f92672>::</span><span style=color:#66d9ef>Three</span>) (u<span style=color:#f92672>::</span><span style=color:#66d9ef>Zero</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>Succ</span> (<span style=color:#66d9ef>Succ</span> (<span style=color:#66d9ef>Succ</span> <span style=color:#66d9ef>Zero</span>))
</span></span></code></pre></div><blockquote><p>Where <code>u = undefined</code>, just a convenient type alias.</p></blockquote><p>Functional Dependencies have proven to be very useful since it solves a real problem. But software evolves and so Type Families were created, the topic of the next section.</p><h3 id=type-families>Type Families</h3><p>Type Families were introduced in the paper <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/07/typefun.pdf?from=http%3A%2F%2Fresearch.microsoft.com%2F~simonpj%2Fpapers%2Fassoc-types%2Ffun-with-type-funs%2Ftypefun.pdf">Fun with type
functions</a> by Oleg Kiselyov, Simon Peyton Jones and Chung-chieh Shan in May 2010.</p><p>This GHC extension allows functions on types to be expressed as straightforwardly as functions on values. This means
that our functions are executed at compile time, during type checking.</p><p>So here&rsquo;s how we can define our <code>HasLogger</code> class using Type Families instead:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#75715e>{-# LANGUAGE TypeFamilies #-}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> Data.Kind (<span style=color:#66d9ef>Type</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#66d9ef>HasLogger</span> ctx <span style=color:#66d9ef>where</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>type</span> <span style=color:#66d9ef>LoggerF</span> ctx <span style=color:#f92672>::</span> <span style=color:#66d9ef>Type</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Type</span>
</span></span><span style=display:flex><span>  loggerL <span style=color:#f92672>::</span> <span style=color:#66d9ef>Lens&#39;</span> ctx (<span style=color:#66d9ef>Logger</span> (<span style=color:#66d9ef>LoggerF</span> ctx))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>instance</span> <span style=color:#66d9ef>HasLogger</span> (<span style=color:#66d9ef>Ctx</span> m) <span style=color:#66d9ef>where</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>type</span> <span style=color:#66d9ef>LoggerF</span> (<span style=color:#66d9ef>Ctx</span> m) <span style=color:#f92672>=</span> m
</span></span><span style=display:flex><span>  loggerL <span style=color:#f92672>=</span> lens ctxLogger (<span style=color:#a6e22e>\</span>x y <span style=color:#f92672>-&gt;</span> x { ctxLogger <span style=color:#f92672>=</span> y })
</span></span></code></pre></div><p>Our class has once again a single parameter <code>ctx</code> and our functional dependency is now expressed as an <em>associated type</em> of the class (type family). It behaves like a function at the type level, so we can call <code>LoggerF</code> a type function.</p><p>Notice how we explicitly define the kind of our type function to be <code>Type -> Type</code> (formerly <code>* -> *</code>). If we don&rsquo;t do it the default inferred kind will just be <code>Type</code> (formerly <code>*</code>).</p><h4 id=arithmetic-example-1>Arithmetic example</h4><p>In a similar way, we can define the <code>Add</code> class using Type Families:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#66d9ef>Add</span> a b <span style=color:#66d9ef>where</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>type</span> <span style=color:#66d9ef>AddF</span> a b <span style=color:#f92672>::</span> <span style=color:#66d9ef>Type</span>
</span></span><span style=display:flex><span>  add <span style=color:#f92672>::</span> a <span style=color:#f92672>-&gt;</span> b <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>AddF</span> a b
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>instance</span> <span style=color:#66d9ef>Add</span> <span style=color:#66d9ef>Zero</span> b <span style=color:#66d9ef>where</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>type</span> <span style=color:#66d9ef>AddF</span> <span style=color:#66d9ef>Zero</span> b <span style=color:#f92672>=</span> b
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>instance</span> <span style=color:#66d9ef>Add</span> a b <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>Add</span> (<span style=color:#66d9ef>Succ</span> a) b <span style=color:#66d9ef>where</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>type</span> <span style=color:#66d9ef>AddF</span> (<span style=color:#66d9ef>Succ</span> a) b <span style=color:#f92672>=</span> <span style=color:#66d9ef>Succ</span> (<span style=color:#66d9ef>AddF</span> a b)
</span></span></code></pre></div><p>The <code>c</code> parameter defined before is now replaced by the <code>AddF a b</code> type function. Here we define the kind of the type
function as a good practice but it&rsquo;s not necessary.</p><p>And again, we can try this out in the REPL:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#a6e22e>Œª</span> <span style=color:#66d9ef>:</span>t add (u<span style=color:#f92672>::</span><span style=color:#66d9ef>Three</span>) (u<span style=color:#f92672>::</span><span style=color:#66d9ef>Succ</span> <span style=color:#66d9ef>Zero</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>Succ</span> (<span style=color:#66d9ef>Succ</span> (<span style=color:#66d9ef>Succ</span> (<span style=color:#66d9ef>Succ</span> <span style=color:#66d9ef>Zero</span>)))
</span></span></code></pre></div><h4 id=polymorphic-mutable-ref>Polymorphic Mutable Ref</h4><p>Furthermore, with Type Families we could define a polymorphic mutable ref class where <code>m</code> defines <code>Ref</code> (example taken from
the paper <em>Fun with type functions</em> linked above).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#66d9ef>Mutation</span> m <span style=color:#66d9ef>where</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>type</span> <span style=color:#66d9ef>Ref</span> m <span style=color:#f92672>::</span> <span style=color:#66d9ef>Type</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Type</span>
</span></span><span style=display:flex><span>  newRef   <span style=color:#f92672>::</span> a <span style=color:#f92672>-&gt;</span> m (<span style=color:#66d9ef>Ref</span> m a)
</span></span><span style=display:flex><span>  readRef  <span style=color:#f92672>::</span> <span style=color:#66d9ef>Ref</span> m a <span style=color:#f92672>-&gt;</span> m a
</span></span><span style=display:flex><span>  writeRef <span style=color:#f92672>::</span> <span style=color:#66d9ef>Ref</span> m a <span style=color:#f92672>-&gt;</span> a <span style=color:#f92672>-&gt;</span> m ()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>instance</span> <span style=color:#66d9ef>Mutation</span> <span style=color:#66d9ef>IO</span> <span style=color:#66d9ef>where</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>type</span> <span style=color:#66d9ef>Ref</span> <span style=color:#66d9ef>IO</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>IORef</span>
</span></span><span style=display:flex><span>  newRef   <span style=color:#f92672>=</span> newIORef
</span></span><span style=display:flex><span>  readRef  <span style=color:#f92672>=</span> readIORef
</span></span><span style=display:flex><span>  writeRef <span style=color:#f92672>=</span> writeIORef
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>instance</span> <span style=color:#66d9ef>Mutation</span> (<span style=color:#66d9ef>ST</span> s) <span style=color:#66d9ef>where</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>type</span> <span style=color:#66d9ef>Ref</span> (<span style=color:#66d9ef>ST</span> s) <span style=color:#f92672>=</span> <span style=color:#66d9ef>STRef</span> s
</span></span><span style=display:flex><span>  newRef   <span style=color:#f92672>=</span> newSTRef
</span></span><span style=display:flex><span>  readRef  <span style=color:#f92672>=</span> readSTRef
</span></span><span style=display:flex><span>  writeRef <span style=color:#f92672>=</span> writeSTRef
</span></span></code></pre></div><p>Once the compiler knows what <code>m</code> is it&rsquo;s over. It&rsquo;ll know what the type of the mutable ref is as well. And as a bonus, type inference will work flawlessly.</p><h3 id=final-thoughts>Final Thoughts</h3><p>Most use cases of <code>FunctionalDependencies</code> can be expressed using <code>TypeFamilies</code>, however there are some subtle differences that come to light only in complex scenarios.</p><p>Most library authors and developers prefer to use <code>TypeFamilies</code> nowadays. Its main advantage over <code>FunctionalDependencies</code> is speed but it&rsquo;s also possible to express many cases that require the extensions <code>TypeSynonymInstances</code>, <code>FlexibleInstances</code>, <code>MultiParamTypeClasses</code> and <code>UndecidableInstances</code> without them.</p><p>So when is it more convenient to use the former? You can find a more detailed comparison in the following articles:</p><ul><li><a href=https://wiki.haskell.org/Functional_dependencies_vs._type_families>https://wiki.haskell.org/Functional_dependencies_vs._type_families</a></li><li><a href=https://gitlab.haskell.org/ghc/ghc/wikis/tf-vs-fd>https://gitlab.haskell.org/ghc/ghc/wikis/tf-vs-fd</a></li></ul><p>Special thanks to <a href=https://twitter.com/ChShersh>Dmitrii Kovanikov</a> for reviewing the first draft!</p></div><div class=related-posts><h3>Related Content</h3><div class=related-grid><div class=related-post><h4><a href=https://gvolpe.com/talks/medellin-2019/>Entering a Purely Functional World @ Scala MDE Meetup 2019 - Medellin, CO üá®üá¥</a></h4><div class=related-meta>2019.08.09 ‚Ä¢
üéôÔ∏è Public Talk</div></div><div class=related-post><h4><a href=https://gvolpe.com/blog/lessons-learned-while-writing-a-haskell-app/>Lessons learned while writing a Haskell application</a></h4><div class=related-meta>2019.06.23 ‚Ä¢
üìöüìöüìöüìöüìö 9 min read</div></div><div class=related-post><h4><a href=https://gvolpe.com/talks/tokyo-2020/>Haskell for Scala devs @ Tokyo Scala Meetup 2019 - Tokyo, JP üáØüáµ</a></h4><div class=related-meta>2019.02.01 ‚Ä¢
üéôÔ∏è Public Talk</div></div></div></div><nav class=post-navigation><div class=nav-previous><span class=nav-label>‚Üê Previous</span>
<a href=https://gvolpe.com/blog/lessons-learned-while-writing-a-haskell-app/ class=nav-title>Lessons learned while writing a Haskell application</a></div><div class=nav-next><span class=nav-label>Next ‚Üí</span>
<a href=https://gvolpe.com/blog/the-art-of-interviewing-engineers/ class=nav-title>The art of interviewing engineers</a></div></nav></article><aside class=sidebar><nav class=toc><h4>Contents</h4><div id=toc-content></div></nav></aside></div></div></div></main><script src=https://gvolpe.com/js/main.js></script></body></html>
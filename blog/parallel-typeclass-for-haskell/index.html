<!DOCTYPE html> <html> <head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <!--<meta name="viewport" content="width=device-width, initial-scale=1">--> <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" /> <title> Parallel typeclass for Haskell &bull; gvolpe's blog </title> <meta name="description" content="As I’m preparing a talk about refinement types I will be giving this Thursday at the Functional Tricity Meetup, and I’ve recently given a similar talk using ..."> <link rel="icon" href="/images/favicon.png"> <link rel="canonical" href="https://gvolpe.github.io/blog/parallel-typeclass-for-haskell/"> <link rel="alternate" type="application/rss+xml" title="gvolpe's blog" href="https://gvolpe.github.io/blog/feed.xml" /> <link rel="stylesheet" href="/css/main.css"> <link rel="stylesheet" href="/assets/css/main.css"/> <!--Also needs to be set in ./_layouts/unified.html--> <script defer data-domain="gvolpe.com" src="https://analytics.gvolpe.com/js/script.js"></script> <noscript><link rel="stylesheet" href="/assets/css/noscript.css" /></noscript> </head> <body class=""> <header id="header"> <h1> <a href="/blog">Gabriel Volpe's blog</a> </h1> <div class="overlay"> <div class="container"> <nav> <ul> <li><a href="/">Home</a></li> <li><a href="/blog/categories/">Categories</a></li> <li><button id="wheel" style="background:#0f1514">Accessibility</button></li> </ul> </nav> </div> </div> </header> <script type="text/javascript"> document.getElementById("wheel").onclick = function() { const elem = document.getElementById("projects"); if (elem != null) { elem.id="accessible"; } else { document.getElementById("accessible").id="projects"; } return false; }; </script> <section id="projects" class="main style-post dark fullscreen"> <div class="content"> <div class="post-content"> <header class="post-header"> <h1 class="post-title">Parallel typeclass for Haskell</h1> <span class="post-meta"> <time class="post-date" datetime="2020-04-20">Apr 20, 2020</time> <span class="post-author">by <a href="/">Gabriel Volpe</a></span> </span> <div class="post-categories"> <span class="post-meta"> <a href="/blog/categories/#haskell" class="cat-link">haskell</a> &nbsp; <a href="/blog/categories/#parallel" class="cat-link">parallel</a> &nbsp; <a href="/blog/categories/#validation" class="cat-link">validation</a> &nbsp; <a href="/blog/categories/#purescript" class="cat-link">purescript</a> &nbsp; <a href="/blog/categories/#scala" class="cat-link">scala</a> </span> </div> </header> <p>As I’m preparing a talk about refinement types I will be giving this Thursday at the <a href="https://www.meetup.com/FunctionalTricity/events/269763842/">Functional Tricity Meetup</a>, and I’ve recently given a <a href="https://scala.love/gabriel-volpe-why-types-matter/">similar talk</a> using the Scala language as well, I realized there is a missing typeclass in Haskell.</p> <p>In the following sections, I will be providing examples and use cases for this typeclass to showcase why it would be great to have it in Haskell. Oh, yes… I love refinement types as well!</p> <p>In Haskell, we have the <a href="https://hackage.haskell.org/package/refined">refined</a> library and other more complex tools such as <a href="https://hackage.haskell.org/package/liquidhaskell">Liquid Haskell</a>.</p> <h3 id="refinement-types">Refinement types</h3> <p>Refinement types give us the ability to define validation rules, or more commonly called <em>predicates</em>, at the type level. This means we get compile-time validation whenever the values are known at compile-time.</p> <p>Say we have the following predicates and datatype:</p> <div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">import</span> <span class="nn">Refined</span>

<span class="kr">type</span> <span class="kt">Age</span>  <span class="ow">=</span> <span class="kt">Refine</span> <span class="p">(</span><span class="kt">GreaterThan</span> <span class="mi">17</span><span class="p">)</span> <span class="kt">Int</span>
<span class="kr">type</span> <span class="kt">Name</span> <span class="ow">=</span> <span class="kt">Refine</span> <span class="kt">NonEmpty</span> <span class="kt">Text</span>

<span class="kr">data</span> <span class="kt">Person</span> <span class="ow">=</span> <span class="kt">Person</span>
  <span class="p">{</span> <span class="n">personAge</span> <span class="ow">::</span> <span class="kt">Age</span>
  <span class="p">,</span> <span class="n">personName</span> <span class="ow">::</span> <span class="kt">Name</span>
  <span class="p">}</span> <span class="kr">deriving</span> <span class="kt">Show</span></code></pre></div> <p>We can validate the creation of <code>Person</code> at compile-time using Template Haskell:</p> <div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="nf">me</span> <span class="ow">::</span> <span class="kt">Person</span>
<span class="nf">me</span> <span class="ow">=</span> <span class="kt">Person</span> <span class="o">$$</span><span class="p">(</span><span class="n">refineTH</span> <span class="mi">32</span><span class="p">)</span> <span class="o">$$</span><span class="p">(</span><span class="n">refineTH</span> <span class="s">&quot;Gabriel&quot;</span><span class="p">)</span></code></pre></div> <p>If the age was a number under 18, or the name was an empty string, then our program wouldn’t compile. Isn’t that cool?</p> <p>Though, most of the time, we need to validate incoming data from external services, meaning <em>runtime validation</em>. Refined gives us a bunch of useful functions to achieve this, effectively replacing <em>smart constructors</em>. The most common one is defined as follows:</p> <div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="nf">refine</span> <span class="ow">::</span> <span class="kt">Predicate</span> <span class="n">p</span> <span class="n">x</span> <span class="ow">=&gt;</span> <span class="n">x</span> <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="kt">RefineException</span> <span class="p">(</span><span class="kt">Refined</span> <span class="n">p</span> <span class="n">x</span><span class="p">)</span></code></pre></div> <p>We can then use this function to validate our input data.</p> <div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="nf">mkPerson</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Text</span> <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="kt">RefineException</span> <span class="kt">Person</span>
<span class="nf">mkPerson</span> <span class="n">a</span> <span class="n">n</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">age</span>  <span class="ow">&lt;-</span> <span class="n">refine</span> <span class="n">a</span>
  <span class="n">name</span> <span class="ow">&lt;-</span> <span class="n">refine</span> <span class="n">n</span>
  <span class="n">return</span> <span class="o">$</span> <span class="kt">Person</span> <span class="n">age</span> <span class="n">name</span></code></pre></div> <p>However, the program above will short-circuit on the first error, as any other Monad will do. It would be nice if we could validate all our inputs in parallel and accumulates errors, wouldn’t it?</p> <p>We can achieve this by converting our <code>Either</code> values given by <code>refine a</code> into <code>Validation</code>, use <code>Applicative</code> functions to compose the different parts, and finally converting back to <code>Either</code>.</p> <div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">import</span> <span class="nn">Data.Validation</span>

<span class="nf">mkPerson</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Text</span> <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="kt">RefineException</span> <span class="kt">Person</span>
<span class="nf">mkPerson</span> <span class="n">a</span> <span class="n">n</span> <span class="ow">=</span> <span class="n">toEither</span> <span class="o">$</span> <span class="kt">Person</span>
  <span class="o">&lt;$&gt;</span> <span class="n">fromEither</span> <span class="p">(</span><span class="n">refine</span> <span class="n">a</span><span class="p">)</span>
  <span class="o">&lt;*&gt;</span> <span class="n">fromEither</span> <span class="p">(</span><span class="n">refine</span> <span class="n">n</span><span class="p">)</span></code></pre></div> <p>As we can see, it is a bit clunky, and this is a very repetitive task, which will only increase the amount of boilerplate in our codebase.</p> <p>This seems to be the <em>status quo</em> around validation in Haskell nowadays, and it was the same in Scala. So it’s kind of hard to realize we are missing what we don’t know: the <code>Parallel</code> typeclass. I didn’t know it was such a game changer until I started using it everywhere.</p> <p>This is exactly what this typeclass does for us in other languages, via its helpful functions and instances. Unfortunately, it doesn’t exist in Haskell, as far as I know… until now!</p> <h3 id="parallel-typeclass">Parallel typeclass</h3> <p>Let me introduce you to the <code>Parallel</code> typeclass, already present in <a href="https://pursuit.purescript.org/packages/purescript-parallel/4.0.0/docs/Control.Parallel.Class#t:Parallel">PureScript</a> and <a href="https://github.com/typelevel/cats/blob/master/core/src/main/scala/cats/Parallel.scala#L10">Scala</a>:</p> <div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">import</span> <span class="nn">Control.Natural</span> <span class="p">((</span><span class="o">:~&gt;</span><span class="p">))</span>

<span class="kr">class</span> <span class="p">(</span><span class="kt">Monad</span> <span class="n">m</span><span class="p">,</span> <span class="kt">Applicative</span> <span class="n">f</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Parallel</span> <span class="n">f</span> <span class="n">m</span> <span class="o">|</span> <span class="n">m</span> <span class="ow">-&gt;</span> <span class="n">f</span><span class="p">,</span> <span class="n">f</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="kr">where</span>
  <span class="n">parallel</span> <span class="ow">::</span> <span class="n">m</span> <span class="kt">:~&gt;</span> <span class="n">f</span>
  <span class="n">sequential</span> <span class="ow">::</span> <span class="n">f</span> <span class="kt">:~&gt;</span> <span class="n">m</span></code></pre></div> <p>It defines a relationship between a <code>Monad</code> that can also be an <code>Applicative</code> with “parallely” behavior. That is, an <code>Applicative</code> instance that wouln’t pass the monadic laws.</p> <p>The most common relationship is the one given by <code>Either</code> and <code>Validation</code>. These two types are isomorphic, with the difference being that <code>Validation</code> has an <code>Applicative</code> instance that accumulate errors instead of short-circuiting on the first error.</p> <p>So we can represent this relationship via <em>natural transformation</em> in a <code>Parallel</code> instance:</p> <div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">instance</span> <span class="kt">Semigroup</span> <span class="n">e</span> <span class="ow">=&gt;</span> <span class="kt">Parallel</span> <span class="p">(</span><span class="kt">Validation</span> <span class="n">e</span><span class="p">)</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">e</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">parallel</span>   <span class="ow">=</span> <span class="kt">NT</span> <span class="n">fromEither</span>
  <span class="n">sequential</span> <span class="ow">=</span> <span class="kt">NT</span> <span class="n">toEither</span></code></pre></div> <p>In the same way, we can represent the relationship between <code>[]</code> and <code>ZipList</code>:</p> <div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">instance</span> <span class="kt">Parallel</span> <span class="kt">ZipList</span> <span class="kt">[]</span> <span class="kr">where</span>
  <span class="n">parallel</span>   <span class="ow">=</span> <span class="kt">NT</span> <span class="kt">ZipList</span>
  <span class="n">sequential</span> <span class="ow">=</span> <span class="kt">NT</span> <span class="n">getZipList</span></code></pre></div> <p>Now, all this ceremony only becomes useful if we define some functions based on <code>Parallel</code>. One of the most common ones is <code>parMapN</code> (or <code>parMap2</code> in this case, but ideally, it should be abstracted over its arity).</p> <div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="nf">parMapN</span>
  <span class="ow">::</span> <span class="p">(</span><span class="kt">Applicative</span> <span class="n">f</span><span class="p">,</span> <span class="kt">Monad</span> <span class="n">m</span><span class="p">,</span> <span class="kt">Parallel</span> <span class="n">f</span> <span class="n">m</span><span class="p">)</span>
  <span class="ow">=&gt;</span> <span class="n">m</span> <span class="n">a0</span>
  <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a1</span>
  <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a0</span> <span class="ow">-&gt;</span> <span class="n">a1</span> <span class="ow">-&gt;</span> <span class="n">a</span><span class="p">)</span>
  <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
<span class="nf">parMapN</span> <span class="n">ma0</span> <span class="n">ma1</span> <span class="n">f</span> <span class="ow">=</span> <span class="n">unwrapNT</span> <span class="n">sequential</span>
  <span class="p">(</span><span class="n">f</span> <span class="o">&lt;$&gt;</span> <span class="n">unwrapNT</span> <span class="n">parallel</span> <span class="n">ma0</span> <span class="o">&lt;*&gt;</span> <span class="n">unwrapNT</span> <span class="n">parallel</span> <span class="n">ma1</span><span class="p">)</span></code></pre></div> <p>Before we get to see how we can leverage this function with refinement types and data validation, we will define a type alias for our effect type and a function <code>ref</code>, which will convert <code>RefineException</code>s into a <code>[Text]</code>, since our error type needs to be a <code>Semigroup</code>.</p> <div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">import</span> <span class="nn">Control.Arrow</span> <span class="p">(</span><span class="nf">left</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Data.Text</span>     <span class="p">(</span><span class="nf">pack</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Refined</span>

<span class="kr">type</span> <span class="kt">Eff</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Either</span> <span class="p">[</span><span class="kt">Text</span><span class="p">]</span> <span class="n">a</span>

<span class="nf">ref</span> <span class="ow">::</span> <span class="kt">Predicate</span> <span class="n">p</span> <span class="n">x</span> <span class="ow">=&gt;</span> <span class="n">x</span> <span class="ow">-&gt;</span> <span class="kt">Eff</span> <span class="p">(</span><span class="kt">Refined</span> <span class="n">p</span> <span class="n">x</span><span class="p">)</span>
<span class="nf">ref</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">left</span> <span class="p">(</span><span class="nf">\</span><span class="n">e</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">pack</span> <span class="o">$</span> <span class="n">show</span> <span class="n">e</span><span class="p">])</span> <span class="p">(</span><span class="n">refine</span> <span class="n">x</span><span class="p">)</span></code></pre></div> <p>In the example below, we can appreciate how this function can be used to create a <code>Person</code> instance with validated input data (it’s a breeze):</p> <div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="nf">mkPerson</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Text</span> <span class="ow">-&gt;</span> <span class="kt">Eff</span> <span class="kt">Person</span>
<span class="nf">mkPerson</span> <span class="n">a</span> <span class="n">n</span> <span class="ow">=</span> <span class="n">parMapN</span> <span class="p">(</span><span class="n">ref</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="n">ref</span> <span class="n">n</span><span class="p">)</span> <span class="kt">Person</span></code></pre></div> <p>Our <code>mkPerson</code> is now validating all our inputs in parallel via an implicit round-trip <code>Either</code>/<code>Validation</code> given by our <code>Parallel</code> instance.</p> <p>We can also use <code>parMapN</code> to use a different <code>Applicative</code> instance for lists without manually wrapping / unwrapping <code>ZipList</code>s.</p> <div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="nf">n1</span> <span class="ow">=</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span>
<span class="nf">n2</span> <span class="ow">=</span> <span class="p">[</span><span class="mi">6</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span>

<span class="nf">n3</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span>
<span class="nf">n3</span> <span class="ow">=</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="o">&lt;$&gt;</span> <span class="n">n1</span> <span class="o">&lt;*&gt;</span> <span class="n">n2</span>

<span class="nf">n4</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span>
<span class="nf">n4</span> <span class="ow">=</span> <span class="n">parMapN</span> <span class="n">n1</span> <span class="n">n2</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span></code></pre></div> <p>Without <code>Parallel</code>’s simplicity, it would look as follows:</p> <div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="nf">n4</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span>
<span class="nf">n4</span> <span class="ow">=</span> <span class="n">getZipList</span> <span class="o">$</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="o">&lt;$&gt;</span> <span class="kt">ZipList</span> <span class="n">n1</span> <span class="o">&lt;*&gt;</span> <span class="kt">ZipList</span> <span class="n">n2</span></code></pre></div> <p>For convenience, here’s another function we can define in terms of <code>parMapN</code>:</p> <div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="nf">parTupled</span>
  <span class="ow">::</span> <span class="p">(</span><span class="kt">Applicative</span> <span class="n">f</span><span class="p">,</span> <span class="kt">Monad</span> <span class="n">m</span><span class="p">,</span> <span class="kt">Parallel</span> <span class="n">f</span> <span class="n">m</span><span class="p">)</span>
  <span class="ow">=&gt;</span> <span class="n">m</span> <span class="n">a0</span>
  <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a1</span>
  <span class="ow">-&gt;</span> <span class="n">m</span> <span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="n">a1</span><span class="p">)</span>
<span class="nf">parTupled</span> <span class="n">ma0</span> <span class="n">ma1</span> <span class="ow">=</span> <span class="n">parMapN</span> <span class="n">ma0</span> <span class="n">ma1</span> <span class="p">(,)</span></code></pre></div> <p>In Scala, there’s also an instance for <code>IO</code> and <code>IO.Par</code>, a newtype that provides a different <code>Applicative</code> instance, which allows us to use functions such as <code>parMapN</code> with <code>IO</code> computations to run them in parallel!</p> <p>And this is only the beginning… There are so many other useful functions we could define!</p> <p>For now, the code is presented in <a href="https://github.com/gvolpe/types-matter">this Github repository</a> together with some other examples. Should there be enough interest, I might polish it and ship it as a library.</p> <p>Let me know your thoughts!</p> <p>Gabriel.</p> </div> </div> </section> <footer id="footer"> <!-- Icons --> <!-- Look here for more brands icons: https://fortawesome.com/sets/font-awesome-5-brands --> <ul class="icons"> <li><a href="base64:aGVsbG9AZ3ZvbHBlLmNvbQo=" target="_blank" class="icon solid fa-envelope"><span class="label">Email</span></a></li> <!--<li><a href="https://discordapp.com/channels/@me/510276992156041217" target="_blank" class="icon brands fa-discord"><span class="label">Discord</span></a></li>--> <li><a href="https://github.com/gvolpe" target="_blank" class="icon brands fa-github"><span class="label">Github</span></a></li> <li><a href="https://matrix.to/#/@gvolpe:matrix.org" target="_blank" class="icon brands fa-gitter"><span class="label">Matrix</span></a></li> <li><a rel="me" href="https://fosstodon.org/@gvolpe" target="_blank" class="icon brands fa-mastodon"><span class="label">Mastodon</span>></a></li> <li><a href="https://twitter.com/volpegabriel87" target="_blank" class="icon brands fa-twitter"><span class="label">Twitter</span></a></li> <li><a href="https://bsky.app/profile/gvolpe.com" target="_blank" class="icon brands fa-dribbble"><span class="label">Bluesky</span></a></li> <li><a href="https://linkedin.com/in/gmvolpe" target="_blank" class="icon brands fa-linkedin-in"><span class="label">LinkedIn</span></a></li> <li><a href="https://leanpub.com/u/gvolpe" target="_blank" class="icon brands fa-leanpub"><span class="label">LeanPub</span></a></li> <li><a href="https://www.blurb.co.uk/user/gvolpe" target="_blank" class="icon brands fa-bimobject"><span class="label">Blurb</span></a></li> </ul> <small> Made with <a href="http://jekyllrb.com" target="_blank">Jekyll</a> and by <a href="http://nandomoreira.me" target="_blank">nandomoreira.me</a> </small> <!-- Menu --> <ul class="menu"> <li> &copy; Gabriel Volpe 2020-2024 </li> </ul> </footer> </body> </html></body></html>

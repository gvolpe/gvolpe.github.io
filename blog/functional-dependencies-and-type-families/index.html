<!DOCTYPE html> <html> <head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <!--<meta name="viewport" content="width=device-width, initial-scale=1">--> <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" /> <title> Functional Dependencies & Type Families &bull; gvolpe's blog </title> <meta name="description" content="In the past few months I have learnt a lot! Probably the coolest stuff has been about Functional Dependencies and Type Families, so this is my attempt to exp..."> <link rel="icon" href="/images/favicon.png"> <link rel="canonical" href="https://gvolpe.github.io/blog/functional-dependencies-and-type-families/"> <link rel="alternate" type="application/rss+xml" title="gvolpe's blog" href="https://gvolpe.github.io/blog/feed.xml" /> <link rel="stylesheet" href="/css/main.css"> <link rel="stylesheet" href="/assets/css/main.css"/> <!--Also needs to be set in ./_layouts/unified.html--> <script defer data-domain="gvolpe.com" src="https://analytics.gvolpe.com/js/script.js"></script> <noscript><link rel="stylesheet" href="/assets/css/noscript.css" /></noscript> </head> <body class=""> <header id="header"> <h1> <a href="/blog">Gabriel Volpe's blog</a> </h1> <div class="overlay"> <div class="container"> <nav> <ul> <li><a href="/">Home</a></li> <li><a href="/blog/categories/">Categories</a></li> <li><button id="wheel" style="background:#0f1514">Accessibility</button></li> </ul> </nav> </div> </div> </header> <script type="text/javascript"> document.getElementById("wheel").onclick = function() { const elem = document.getElementById("projects"); if (elem != null) { elem.id="accessible"; } else { document.getElementById("accessible").id="projects"; } return false; }; </script> <section id="projects" class="main style-post dark fullscreen"> <div class="content"> <div class="post-content"> <header class="post-header"> <h1 class="post-title">Functional Dependencies & Type Families</h1> <span class="post-meta"> <time class="post-date" datetime="2019-08-27">Aug 27, 2019</time> <span class="post-author">by <a href="/">Gabriel Volpe</a></span> </span> <div class="post-categories"> <span class="post-meta"> <a href="/blog/categories/#haskell" class="cat-link">haskell</a> </span> </div> </header> <p>In the past few months I have learnt a lot! Probably the coolest stuff has been about <a href="https://wiki.haskell.org/Functional_dependencies">Functional Dependencies</a> and <a href="https://wiki.haskell.org/GHC/Type_families">Type Families</a>, so this is my attempt to explain it in order to gain a better understanding and hopefully help someone else out there as well.</p> <p>So please be kind if you see any mistake, let me know and I’ll try to fix it :)</p> <h3 id="a-motivating-example">A motivating example</h3> <p>One of the fun applications I’ve worked on is <a href="https://github.com/gvolpe/exchange-rates">exchange-rates</a>, which uses the <a href="https://www.fpcomplete.com/blog/2017/07/the-rio-monad">RIO Monad</a> (basically <code>ReaderT</code> + <code>IO</code>).</p> <p>When defining dependencies using such effect is very common to do it using the <a href="https://www.fpcomplete.com/blog/2017/06/readert-design-pattern">Has typeclass approach</a> (or how I prefer to call it, the <em>classy lenses Has pattern</em>) instead of passing the whole context / environment.</p> <p>Following this approach, I have defined a polymorphic <code>Ctx</code> record that represents the application context (or dependencies). It looks as follows:</p> <div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">data</span> <span class="kt">Ctx</span> <span class="n">m</span> <span class="ow">=</span> <span class="kt">Ctx</span>
  <span class="p">{</span> <span class="n">ctxLogger</span> <span class="ow">::</span> <span class="kt">Logger</span> <span class="n">m</span>
  <span class="p">,</span> <span class="n">ctxCache</span> <span class="ow">::</span> <span class="kt">Cache</span> <span class="n">m</span>
  <span class="p">,</span> <span class="n">ctxForexClient</span> <span class="ow">::</span> <span class="kt">ForexClient</span> <span class="n">m</span>
  <span class="p">}</span></code></pre></div> <p>If we continue with the <code>Has</code> approach we would get something like this for our <code>Logger m</code>:</p> <div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">class</span> <span class="kt">HasLogger</span> <span class="n">ctx</span> <span class="kr">where</span>
  <span class="n">loggerL</span> <span class="ow">::</span> <span class="kt">Lens&#39;</span> <span class="n">ctx</span> <span class="p">(</span><span class="kt">Logger</span> <span class="n">m</span><span class="p">)</span>

<span class="kr">instance</span> <span class="kt">HasLogger</span> <span class="p">(</span><span class="kt">Ctx</span> <span class="n">m</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">loggerL</span> <span class="ow">=</span> <span class="n">lens</span> <span class="n">ctxLogger</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="n">y</span> <span class="ow">-&gt;</span> <span class="n">x</span> <span class="p">{</span> <span class="n">ctxLogger</span> <span class="ow">=</span> <span class="n">y</span> <span class="p">})</span></code></pre></div> <p>But… Oops, it doesn’t compile!</p> <div class="highlight"><pre><code class="language-bash" data-lang="bash">Couldn<span class="s1">&#39;t match type ‘m1’ with ‘m’</span>
<span class="s1">      ‘m1’ is a rigid type variable bound by</span>
<span class="s1">        the type signature for:</span>
<span class="s1">          loggerL :: forall (m1 :: * -&gt; *). Lens&#39;</span> <span class="o">(</span>Ctx m<span class="o">)</span> <span class="o">(</span>Logger m1<span class="o">)</span>
        at src/Context.hs:27:3-9
      ‘m’ is a rigid <span class="nb">type </span>variable bound by
        the instance declaration
        at src/Context.hs:26:10-47</code></pre></div> <p>The reason is that the compiler has no way to know that the <code>m</code> in <code>Logger m</code> (declared in the type class) is the same as the <code>m</code> in <code>Ctx m</code> (declared in the instance), therefore the inferred type ends up being <code>Lens' (Ctx m) (Logger m1)</code>.</p> <h3 id="functional-dependencies-to-the-rescue">Functional Dependencies to the rescue</h3> <p>We can fix it by introducing a language extension named <a href="https://wiki.haskell.org/Functional_dependencies">FunctionalDependencies</a>, introduced in the paper <a href="https://web.cecs.pdx.edu/~mpj/pubs/fundeps-esop2000.pdf">Type Classes with Functional Dependencies</a> by Mark P. Jones in March 2000.</p> <p>We need to change our type class definition as below:</p> <div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="cm">{-# LANGUAGE FlexibleInstances      #-}</span>
<span class="cm">{-# LANGUAGE FunctionalDependencies #-}</span>
<span class="cm">{-# LANGUAGE MultiParamTypeClasses  #-}</span>

<span class="kr">class</span> <span class="kt">HasLogger</span> <span class="n">ctx</span> <span class="n">m</span> <span class="o">|</span> <span class="n">ctx</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="kr">where</span>
  <span class="n">loggerL</span> <span class="ow">::</span> <span class="kt">Lens&#39;</span> <span class="n">ctx</span> <span class="p">(</span><span class="kt">Logger</span> <span class="n">m</span><span class="p">)</span>

<span class="kr">instance</span> <span class="kt">HasLogger</span> <span class="p">(</span><span class="kt">Ctx</span> <span class="n">m</span><span class="p">)</span> <span class="n">m</span> <span class="kr">where</span>
  <span class="n">loggerL</span> <span class="ow">=</span> <span class="n">lens</span> <span class="n">ctxLogger</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="n">y</span> <span class="ow">-&gt;</span> <span class="n">x</span> <span class="p">{</span> <span class="n">ctxLogger</span> <span class="ow">=</span> <span class="n">y</span> <span class="p">})</span></code></pre></div> <p>Our type class has now two parameters, <code>ctx</code> and <code>m</code>, and in addition we define a <em>functional dependency</em> <code>ctx -&gt; m</code>. This means that <code>ctx</code> uniquely determines the type of <code>m</code>, which constraints the possible instances and helps with type inference.</p> <blockquote> <p>Notice the extensions we had to enable to make this compile.</p> </blockquote> <h5 id="arithmetic-example">Arithmetic example</h5> <p>Here’s another example taken from the <a href="http://www.cse.chalmers.se/~hallgren/Papers/hallgren.pdf">Fun with Functional Dependencies</a> paper by Thomas Hallgren. What’s simpler that adding two values together?</p> <div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">class</span> <span class="kt">Add</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">|</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">c</span> <span class="kr">where</span>
  <span class="n">add</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">c</span>

<span class="kr">instance</span> <span class="kt">Add</span> <span class="kt">Zero</span> <span class="n">b</span> <span class="n">b</span>
<span class="kr">instance</span> <span class="kt">Add</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="ow">=&gt;</span> <span class="kt">Add</span> <span class="p">(</span><span class="kt">Succ</span> <span class="n">a</span><span class="p">)</span> <span class="n">b</span> <span class="p">(</span><span class="kt">Succ</span> <span class="n">c</span><span class="p">)</span></code></pre></div> <p>The functional dependency is pretty clear: given <code>a</code> and <code>b</code> we can add them together and produce <code>c</code>. So <code>a</code> and <code>b</code> uniquely determine <code>c</code>.</p> <p>Notice how we don’t even need to define <code>add</code>, specifying the types is enough! If it’s still not clear, bear with me and let’s perform type substitution step by step (feel free to skip this part):</p> <p>Given this instance, all we are saying is that:</p> <div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">instance</span> <span class="kt">Add</span> <span class="kt">Zero</span> <span class="n">b</span> <span class="n">b</span> <span class="kr">where</span></code></pre></div> <ul> <li><code>a</code> is defined as <code>Zero</code>.</li> <li><code>b</code> is defined as <code>b</code>.</li> <li><code>c</code> is defined as <code>b</code>.</li> </ul> <p>Since we now know the types of <code>a</code>, <code>b</code> and <code>c</code>, defining the <code>add</code> function becomes redundant:</p> <div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">instance</span> <span class="kt">Add</span> <span class="kt">Zero</span> <span class="n">b</span> <span class="n">b</span> <span class="kr">where</span>
  <span class="n">add</span> <span class="kt">Zero</span> <span class="n">b</span> <span class="ow">=</span> <span class="n">b</span></code></pre></div> <p>Clear now? Awesome! Let’s try this out in the REPL:</p> <div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="nf">λ</span> <span class="kt">:</span><span class="n">t</span> <span class="n">add</span> <span class="p">(</span><span class="n">u</span><span class="ow">::</span><span class="kt">Three</span><span class="p">)</span> <span class="p">(</span><span class="n">u</span><span class="ow">::</span><span class="kt">Zero</span><span class="p">)</span>
<span class="kt">Succ</span> <span class="p">(</span><span class="kt">Succ</span> <span class="p">(</span><span class="kt">Succ</span> <span class="kt">Zero</span><span class="p">))</span></code></pre></div> <blockquote> <p>Where <code>u = undefined</code>, just a convenient type alias.</p> </blockquote> <p>Functional Dependencies have proven to be very useful since it solves a real problem. But software evolves and so Type Families were created, the topic of the next section.</p> <h3 id="type-families">Type Families</h3> <p>Type Families were introduced in the paper <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/07/typefun.pdf?from=http%3A%2F%2Fresearch.microsoft.com%2F~simonpj%2Fpapers%2Fassoc-types%2Ffun-with-type-funs%2Ftypefun.pdf">Fun with type functions</a> by Oleg Kiselyov, Simon Peyton Jones and Chung-chieh Shan in May 2010.</p> <p>This GHC extension allows functions on types to be expressed as straightforwardly as functions on values. This means that our functions are executed at compile time, during type checking.</p> <p>So here’s how we can define our <code>HasLogger</code> class using Type Families instead:</p> <div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="cm">{-# LANGUAGE TypeFamilies #-}</span>

<span class="kr">import</span> <span class="nn">Data.Kind</span> <span class="p">(</span><span class="kt">Type</span><span class="p">)</span>

<span class="kr">class</span> <span class="kt">HasLogger</span> <span class="n">ctx</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="kt">LoggerF</span> <span class="n">ctx</span> <span class="ow">::</span> <span class="kt">Type</span> <span class="ow">-&gt;</span> <span class="kt">Type</span>
  <span class="n">loggerL</span> <span class="ow">::</span> <span class="kt">Lens&#39;</span> <span class="n">ctx</span> <span class="p">(</span><span class="kt">Logger</span> <span class="p">(</span><span class="kt">LoggerF</span> <span class="n">ctx</span><span class="p">))</span>

<span class="kr">instance</span> <span class="kt">HasLogger</span> <span class="p">(</span><span class="kt">Ctx</span> <span class="n">m</span><span class="p">)</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="kt">LoggerF</span> <span class="p">(</span><span class="kt">Ctx</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=</span> <span class="n">m</span>
  <span class="n">loggerL</span> <span class="ow">=</span> <span class="n">lens</span> <span class="n">ctxLogger</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="n">y</span> <span class="ow">-&gt;</span> <span class="n">x</span> <span class="p">{</span> <span class="n">ctxLogger</span> <span class="ow">=</span> <span class="n">y</span> <span class="p">})</span></code></pre></div> <p>Our class has once again a single parameter <code>ctx</code> and our functional dependency is now expressed as an <em>associated type</em> of the class (type family). It behaves like a function at the type level, so we can call <code>LoggerF</code> a type function.</p> <p>Notice how we explicitly define the kind of our type function to be <code>Type -&gt; Type</code> (formerly <code>* -&gt; *</code>). If we don’t do it the default inferred kind will just be <code>Type</code> (formerly <code>*</code>).</p> <h5 id="arithmetic-example-1">Arithmetic example</h5> <p>In a similar way, we can define the <code>Add</code> class using Type Families:</p> <div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">class</span> <span class="kt">Add</span> <span class="n">a</span> <span class="n">b</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="kt">AddF</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">::</span> <span class="kt">Type</span>
  <span class="n">add</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">AddF</span> <span class="n">a</span> <span class="n">b</span>

<span class="kr">instance</span> <span class="kt">Add</span> <span class="kt">Zero</span> <span class="n">b</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="kt">AddF</span> <span class="kt">Zero</span> <span class="n">b</span> <span class="ow">=</span> <span class="n">b</span>

<span class="kr">instance</span> <span class="kt">Add</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=&gt;</span> <span class="kt">Add</span> <span class="p">(</span><span class="kt">Succ</span> <span class="n">a</span><span class="p">)</span> <span class="n">b</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="kt">AddF</span> <span class="p">(</span><span class="kt">Succ</span> <span class="n">a</span><span class="p">)</span> <span class="n">b</span> <span class="ow">=</span> <span class="kt">Succ</span> <span class="p">(</span><span class="kt">AddF</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span></code></pre></div> <p>The <code>c</code> parameter defined before is now replaced by the <code>AddF a b</code> type function. Here we define the kind of the type function as a good practice but it’s not necessary.</p> <p>And again, we can try this out in the REPL:</p> <div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="nf">λ</span> <span class="kt">:</span><span class="n">t</span> <span class="n">add</span> <span class="p">(</span><span class="n">u</span><span class="ow">::</span><span class="kt">Three</span><span class="p">)</span> <span class="p">(</span><span class="n">u</span><span class="ow">::</span><span class="kt">Succ</span> <span class="kt">Zero</span><span class="p">)</span>
<span class="kt">Succ</span> <span class="p">(</span><span class="kt">Succ</span> <span class="p">(</span><span class="kt">Succ</span> <span class="p">(</span><span class="kt">Succ</span> <span class="kt">Zero</span><span class="p">)))</span></code></pre></div> <h5 id="polymorphic-mutable-ref">Polymorphic Mutable Ref</h5> <p>Furthermore, with Type Families we could define a polymorphic mutable ref class where <code>m</code> defines <code>Ref</code> (example taken from the paper <em>Fun with type functions</em> linked above).</p> <div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">class</span> <span class="kt">Mutation</span> <span class="n">m</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="kt">Ref</span> <span class="n">m</span> <span class="ow">::</span> <span class="kt">Type</span> <span class="ow">-&gt;</span> <span class="kt">Type</span>
  <span class="n">newRef</span>   <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="p">(</span><span class="kt">Ref</span> <span class="n">m</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">readRef</span>  <span class="ow">::</span> <span class="kt">Ref</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
  <span class="n">writeRef</span> <span class="ow">::</span> <span class="kt">Ref</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="nb">()</span>

<span class="kr">instance</span> <span class="kt">Mutation</span> <span class="kt">IO</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="kt">Ref</span> <span class="kt">IO</span> <span class="ow">=</span> <span class="kt">IORef</span>
  <span class="n">newRef</span>   <span class="ow">=</span> <span class="n">newIORef</span>
  <span class="n">readRef</span>  <span class="ow">=</span> <span class="n">readIORef</span>
  <span class="n">writeRef</span> <span class="ow">=</span> <span class="n">writeIORef</span>

<span class="kr">instance</span> <span class="kt">Mutation</span> <span class="p">(</span><span class="kt">ST</span> <span class="n">s</span><span class="p">)</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="kt">Ref</span> <span class="p">(</span><span class="kt">ST</span> <span class="n">s</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">STRef</span> <span class="n">s</span>
  <span class="n">newRef</span>   <span class="ow">=</span> <span class="n">newSTRef</span>
  <span class="n">readRef</span>  <span class="ow">=</span> <span class="n">readSTRef</span>
  <span class="n">writeRef</span> <span class="ow">=</span> <span class="n">writeSTRef</span></code></pre></div> <p>Once the compiler knows what <code>m</code> is it’s over. It’ll know what the type of the mutable ref is as well. And as a bonus, type inference will work flawlessly.</p> <h3 id="final-thoughts">Final Thoughts</h3> <p>Most use cases of <code>FunctionalDependencies</code> can be expressed using <code>TypeFamilies</code>, however there are some subtle differences that come to light only in complex scenarios.</p> <p>Most library authors and developers prefer to use <code>TypeFamilies</code> nowadays. Its main advantage over <code>FunctionalDependencies</code> is speed but it’s also possible to express many cases that require the extensions <code>TypeSynonymInstances</code>, <code>FlexibleInstances</code>, <code>MultiParamTypeClasses</code> and <code>UndecidableInstances</code> without them.</p> <p>So when is it more convenient to use the former? You can find a more detailed comparison in the following articles:</p> <ul> <li>https://wiki.haskell.org/Functional_dependencies_vs._type_families</li> <li>https://gitlab.haskell.org/ghc/ghc/wikis/tf-vs-fd</li> </ul> <p>Special thanks to <a href="https://twitter.com/ChShersh">Dmitrii Kovanikov</a> for reviewing the first draft!</p> </div> </div> </section> <footer id="footer"> <!-- Icons --> <!-- Look here for more brands icons: https://fortawesome.com/sets/font-awesome-5-brands --> <ul class="icons"> <li><a href="base64:aGVsbG9AZ3ZvbHBlLmNvbQo=" target="_blank" class="icon solid fa-envelope"><span class="label">Email</span></a></li> <!--<li><a href="https://discordapp.com/channels/@me/510276992156041217" target="_blank" class="icon brands fa-discord"><span class="label">Discord</span></a></li>--> <li><a href="https://github.com/gvolpe" target="_blank" class="icon brands fa-github"><span class="label">Github</span></a></li> <li><a href="https://matrix.to/#/@gvolpe:matrix.org" target="_blank" class="icon brands fa-gitter"><span class="label">Matrix</span></a></li> <li><a rel="me" href="https://fosstodon.org/@gvolpe" target="_blank" class="icon brands fa-mastodon"><span class="label">Mastodon</span>></a></li> <li><a href="https://twitter.com/volpegabriel87" target="_blank" class="icon brands fa-twitter"><span class="label">Twitter</span></a></li> <li><a href="https://bsky.app/profile/gvolpe.com" target="_blank" class="icon brands fa-dribbble"><span class="label">Bluesky</span></a></li> <li><a href="https://linkedin.com/in/gmvolpe" target="_blank" class="icon brands fa-linkedin-in"><span class="label">LinkedIn</span></a></li> <li><a href="https://leanpub.com/u/gvolpe" target="_blank" class="icon brands fa-leanpub"><span class="label">LeanPub</span></a></li> <li><a href="https://www.blurb.co.uk/user/gvolpe" target="_blank" class="icon brands fa-bimobject"><span class="label">Blurb</span></a></li> </ul> <small> Made with <a href="http://jekyllrb.com" target="_blank">Jekyll</a> and by <a href="http://nandomoreira.me" target="_blank">nandomoreira.me</a> </small> <!-- Menu --> <ul class="menu"> <li> &copy; Gabriel Volpe 2020-2024 </li> </ul> </footer> </body> </html></body></html>

<!doctype html><html lang=en-us data-theme=light><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel=icon href=https://gvolpe.com/images/favicon.png><title>Parallel typeclass for Haskell - Gabriel Volpe</title><meta name=description content="As I&rsquo;m preparing a talk about refinement types I will be giving this Thursday at the Functional Tricity Meetup, and I&rsquo;ve recently given a similar ‚Ä¶"><meta property="og:title" content="Parallel typeclass for Haskell"><meta property="og:description" content="As I&rsquo;m preparing a talk about refinement types I will be giving this Thursday at the Functional Tricity Meetup, and I&rsquo;ve recently given a similar ‚Ä¶"><meta property="og:type" content="article"><meta property="og:url" content="https://gvolpe.com/blog/parallel-typeclass-for-haskell/"><meta property="og:site_name" content="Gabriel Volpe"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="Parallel typeclass for Haskell"><meta name=twitter:description content="As I&rsquo;m preparing a talk about refinement types I will be giving this Thursday at the Functional Tricity Meetup, and I&rsquo;ve recently given a similar ‚Ä¶"><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Orbitron:wght@400;700&family=JetBrains+Mono:wght@400;500&display=swap" rel=stylesheet><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css><link rel=stylesheet href=https://gvolpe.com/css/style.css></head><body><div class=reading-progress></div><main><div class="post-overlay active"><div class=post-overlay-backdrop></div><div class=post-overlay-content style=position:relative;min-height:100vh;padding:0;transform:translateY(0)><div class=post-overlay-header><div class=post-overlay-title><a href=/ class=overlay-site-title>Gabriel Volpe</a></div><button class=post-overlay-close aria-label="Close post" onclick='window.location.href="/"'>
<i class="fas fa-times"></i></button></div><div class=post-layout><article class=post-content><header class=post-header><div class=post-meta><span class=post-date>2020.04.20</span><div class=reading-time-post><span class=coffee-cups>üìöüìöüìöüìöüìö
</span><span>6 min read</span></div></div><h1 class=post-title>Parallel typeclass for Haskell</h1><div class=post-tags-header><a href=https://gvolpe.com/tags/haskell class=post-tag>haskell</a>
<a href=https://gvolpe.com/tags/purescript class=post-tag>purescript</a>
<a href=https://gvolpe.com/tags/scala class=post-tag>scala</a></div></header><div class=post-body><p>As I&rsquo;m preparing a talk about refinement types I will be giving this Thursday at the <a href=https://www.meetup.com/FunctionalTricity/events/269763842/>Functional Tricity Meetup</a>, and I&rsquo;ve recently given a <a href=https://scala.love/gabriel-volpe-why-types-matter/>similar talk</a> using the Scala language as well, I realized there is a missing typeclass in Haskell.</p><p>In the following sections, I will be providing examples and use cases for this typeclass to showcase why it would be great to have it in Haskell. Oh, yes&mldr; I love refinement types as well!</p><p>In Haskell, we have the <a href=https://hackage.haskell.org/package/refined>refined</a> library and other more complex tools such as <a href=https://hackage.haskell.org/package/liquidhaskell>Liquid Haskell</a>.</p><h3 id=refinement-types>Refinement types</h3><p>Refinement types give us the ability to define validation rules, or more commonly called <em>predicates</em>, at the type level. This means we get compile-time validation whenever the values are known at compile-time.</p><p>Say we have the following predicates and datatype:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#66d9ef>import</span> Refined
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#66d9ef>Age</span>  <span style=color:#f92672>=</span> <span style=color:#66d9ef>Refine</span> (<span style=color:#66d9ef>GreaterThan</span> <span style=color:#ae81ff>17</span>) <span style=color:#66d9ef>Int</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#66d9ef>Name</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>Refine</span> <span style=color:#66d9ef>NonEmpty</span> <span style=color:#66d9ef>Text</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>data</span> <span style=color:#66d9ef>Person</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>Person</span>
</span></span><span style=display:flex><span>  { personAge <span style=color:#f92672>::</span> <span style=color:#66d9ef>Age</span>
</span></span><span style=display:flex><span>  , personName <span style=color:#f92672>::</span> <span style=color:#66d9ef>Name</span>
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>deriving</span> <span style=color:#66d9ef>Show</span>
</span></span></code></pre></div><p>We can validate the creation of <code>Person</code> at compile-time using Template Haskell:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#a6e22e>me</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Person</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>me</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>Person</span> <span style=color:#f92672>$$</span>(refineTH <span style=color:#ae81ff>32</span>) <span style=color:#f92672>$$</span>(refineTH <span style=color:#e6db74>&#34;Gabriel&#34;</span>)
</span></span></code></pre></div><p>If the age was a number under 18, or the name was an empty string, then our program wouldn&rsquo;t compile. Isn&rsquo;t that cool?</p><p>Though, most of the time, we need to validate incoming data from external services, meaning <em>runtime validation</em>. Refined gives us a bunch of useful functions to achieve this, effectively replacing <em>smart constructors</em>. The most common one is defined as follows:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#a6e22e>refine</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Predicate</span> p x <span style=color:#f92672>=&gt;</span> x <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Either</span> <span style=color:#66d9ef>RefineException</span> (<span style=color:#66d9ef>Refined</span> p x)
</span></span></code></pre></div><p>We can then use this function to validate our input data.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#a6e22e>mkPerson</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Int</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Text</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Either</span> <span style=color:#66d9ef>RefineException</span> <span style=color:#66d9ef>Person</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>mkPerson</span> a n <span style=color:#f92672>=</span> <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>  age  <span style=color:#f92672>&lt;-</span> refine a
</span></span><span style=display:flex><span>  name <span style=color:#f92672>&lt;-</span> refine n
</span></span><span style=display:flex><span>  return <span style=color:#f92672>$</span> <span style=color:#66d9ef>Person</span> age name
</span></span></code></pre></div><p>However, the program above will short-circuit on the first error, as any other Monad will do. It would be nice if we could validate all our inputs in parallel and accumulates errors, wouldn&rsquo;t it?</p><p>We can achieve this by converting our <code>Either</code> values given by <code>refine a</code> into <code>Validation</code>, use <code>Applicative</code> functions to compose the different parts, and finally converting back to <code>Either</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#66d9ef>import</span> Data.Validation
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>mkPerson</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Int</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Text</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Either</span> <span style=color:#66d9ef>RefineException</span> <span style=color:#66d9ef>Person</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>mkPerson</span> a n <span style=color:#f92672>=</span> toEither <span style=color:#f92672>$</span> <span style=color:#66d9ef>Person</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;$&gt;</span> fromEither (refine a)
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;*&gt;</span> fromEither (refine n)
</span></span></code></pre></div><p>As we can see, it is a bit clunky, and this is a very repetitive task, which will only increase the amount of boilerplate in our codebase.</p><p>This seems to be the <em>status quo</em> around validation in Haskell nowadays, and it was the same in Scala. So it&rsquo;s kind of hard to realize we are missing what we don&rsquo;t know: the <code>Parallel</code> typeclass. I didn&rsquo;t know it was such a game changer until I started using it everywhere.</p><p>This is exactly what this typeclass does for us in other languages, via its helpful functions and instances. Unfortunately, it doesn&rsquo;t exist in Haskell, as far as I know&mldr; until now!</p><h3 id=parallel-typeclass>Parallel typeclass</h3><p>Let me introduce you to the <code>Parallel</code> typeclass, already present in <a href=https://pursuit.purescript.org/packages/purescript-parallel/4.0.0/docs/Control.Parallel.Class#t:Parallel>PureScript</a> and <a href=https://github.com/typelevel/cats/blob/master/core/src/main/scala/cats/Parallel.scala#L10>Scala</a>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#66d9ef>import</span> Control.Natural ((<span style=color:#f92672>:~&gt;</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> (<span style=color:#66d9ef>Monad</span> m, <span style=color:#66d9ef>Applicative</span> f) <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>Parallel</span> f m <span style=color:#f92672>|</span> m <span style=color:#f92672>-&gt;</span> f, f <span style=color:#f92672>-&gt;</span> m <span style=color:#66d9ef>where</span>
</span></span><span style=display:flex><span>  parallel <span style=color:#f92672>::</span> m <span style=color:#66d9ef>:~&gt;</span> f
</span></span><span style=display:flex><span>  sequential <span style=color:#f92672>::</span> f <span style=color:#66d9ef>:~&gt;</span> m
</span></span></code></pre></div><p>It defines a relationship between a <code>Monad</code> that can also be an <code>Applicative</code> with &ldquo;parallely&rdquo; behavior. That is, an <code>Applicative</code> instance that wouln&rsquo;t pass the monadic laws.</p><p>The most common relationship is the one given by <code>Either</code> and <code>Validation</code>. These two types are isomorphic, with the difference being that <code>Validation</code> has an <code>Applicative</code> instance that accumulate errors instead of short-circuiting on the first error.</p><p>So we can represent this relationship via <em>natural transformation</em> in a <code>Parallel</code> instance:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#66d9ef>instance</span> <span style=color:#66d9ef>Semigroup</span> e <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>Parallel</span> (<span style=color:#66d9ef>Validation</span> e) (<span style=color:#66d9ef>Either</span> e) <span style=color:#66d9ef>where</span>
</span></span><span style=display:flex><span>  parallel   <span style=color:#f92672>=</span> <span style=color:#66d9ef>NT</span> fromEither
</span></span><span style=display:flex><span>  sequential <span style=color:#f92672>=</span> <span style=color:#66d9ef>NT</span> toEither
</span></span></code></pre></div><p>In the same way, we can represent the relationship between <code>[]</code> and <code>ZipList</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#66d9ef>instance</span> <span style=color:#66d9ef>Parallel</span> <span style=color:#66d9ef>ZipList</span> <span style=color:#66d9ef>[]</span> <span style=color:#66d9ef>where</span>
</span></span><span style=display:flex><span>  parallel   <span style=color:#f92672>=</span> <span style=color:#66d9ef>NT</span> <span style=color:#66d9ef>ZipList</span>
</span></span><span style=display:flex><span>  sequential <span style=color:#f92672>=</span> <span style=color:#66d9ef>NT</span> getZipList
</span></span></code></pre></div><p>Now, all this ceremony only becomes useful if we define some functions based on <code>Parallel</code>. One of the most common ones is <code>parMapN</code> (or <code>parMap2</code> in this case, but ideally, it should be abstracted over its arity).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#a6e22e>parMapN</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>::</span> (<span style=color:#66d9ef>Applicative</span> f, <span style=color:#66d9ef>Monad</span> m, <span style=color:#66d9ef>Parallel</span> f m)
</span></span><span style=display:flex><span>  <span style=color:#f92672>=&gt;</span> m a0
</span></span><span style=display:flex><span>  <span style=color:#f92672>-&gt;</span> m a1
</span></span><span style=display:flex><span>  <span style=color:#f92672>-&gt;</span> (a0 <span style=color:#f92672>-&gt;</span> a1 <span style=color:#f92672>-&gt;</span> a)
</span></span><span style=display:flex><span>  <span style=color:#f92672>-&gt;</span> m a
</span></span><span style=display:flex><span><span style=color:#a6e22e>parMapN</span> ma0 ma1 f <span style=color:#f92672>=</span> unwrapNT sequential
</span></span><span style=display:flex><span>  (f <span style=color:#f92672>&lt;$&gt;</span> unwrapNT parallel ma0 <span style=color:#f92672>&lt;*&gt;</span> unwrapNT parallel ma1)
</span></span></code></pre></div><p>Before we get to see how we can leverage this function with refinement types and data validation, we will define a type alias for our effect type and a function <code>ref</code>, which will convert <code>RefineException</code>s into a <code>[Text]</code>, since our error type needs to be a <code>Semigroup</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#66d9ef>import</span> Control.Arrow (<span style=color:#a6e22e>left</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> Data.Text     (<span style=color:#a6e22e>pack</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> Refined
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#66d9ef>Eff</span> a <span style=color:#f92672>=</span> <span style=color:#66d9ef>Either</span> [<span style=color:#66d9ef>Text</span>] a
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ref</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Predicate</span> p x <span style=color:#f92672>=&gt;</span> x <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Eff</span> (<span style=color:#66d9ef>Refined</span> p x)
</span></span><span style=display:flex><span><span style=color:#a6e22e>ref</span> x <span style=color:#f92672>=</span> left (<span style=color:#a6e22e>\</span>e <span style=color:#f92672>-&gt;</span> [pack <span style=color:#f92672>$</span> show e]) (refine x)
</span></span></code></pre></div><p>In the example below, we can appreciate how this function can be used to create a <code>Person</code> instance with validated input data (it&rsquo;s a breeze):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#a6e22e>mkPerson</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Int</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Text</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Eff</span> <span style=color:#66d9ef>Person</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>mkPerson</span> a n <span style=color:#f92672>=</span> parMapN (ref a) (ref n) <span style=color:#66d9ef>Person</span>
</span></span></code></pre></div><p>Our <code>mkPerson</code> is now validating all our inputs in parallel via an implicit round-trip <code>Either</code>/<code>Validation</code> given by our <code>Parallel</code> instance.</p><p>We can also use <code>parMapN</code> to use a different <code>Applicative</code> instance for lists without manually wrapping / unwrapping <code>ZipList</code>s.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#a6e22e>n1</span> <span style=color:#f92672>=</span> [<span style=color:#ae81ff>1</span><span style=color:#f92672>..</span><span style=color:#ae81ff>5</span>]
</span></span><span style=display:flex><span><span style=color:#a6e22e>n2</span> <span style=color:#f92672>=</span> [<span style=color:#ae81ff>6</span><span style=color:#f92672>..</span><span style=color:#ae81ff>10</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>n3</span> <span style=color:#f92672>::</span> [<span style=color:#66d9ef>Int</span>]
</span></span><span style=display:flex><span><span style=color:#a6e22e>n3</span> <span style=color:#f92672>=</span> (<span style=color:#f92672>+</span>) <span style=color:#f92672>&lt;$&gt;</span> n1 <span style=color:#f92672>&lt;*&gt;</span> n2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>n4</span> <span style=color:#f92672>::</span> [<span style=color:#66d9ef>Int</span>]
</span></span><span style=display:flex><span><span style=color:#a6e22e>n4</span> <span style=color:#f92672>=</span> parMapN n1 n2 (<span style=color:#f92672>+</span>)
</span></span></code></pre></div><p>Without <code>Parallel</code>&rsquo;s simplicity, it would look as follows:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#a6e22e>n4</span> <span style=color:#f92672>::</span> [<span style=color:#66d9ef>Int</span>]
</span></span><span style=display:flex><span><span style=color:#a6e22e>n4</span> <span style=color:#f92672>=</span> getZipList <span style=color:#f92672>$</span> (<span style=color:#f92672>+</span>) <span style=color:#f92672>&lt;$&gt;</span> <span style=color:#66d9ef>ZipList</span> n1 <span style=color:#f92672>&lt;*&gt;</span> <span style=color:#66d9ef>ZipList</span> n2
</span></span></code></pre></div><p>For convenience, here&rsquo;s another function we can define in terms of <code>parMapN</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#a6e22e>parTupled</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>::</span> (<span style=color:#66d9ef>Applicative</span> f, <span style=color:#66d9ef>Monad</span> m, <span style=color:#66d9ef>Parallel</span> f m)
</span></span><span style=display:flex><span>  <span style=color:#f92672>=&gt;</span> m a0
</span></span><span style=display:flex><span>  <span style=color:#f92672>-&gt;</span> m a1
</span></span><span style=display:flex><span>  <span style=color:#f92672>-&gt;</span> m (a0, a1)
</span></span><span style=display:flex><span><span style=color:#a6e22e>parTupled</span> ma0 ma1 <span style=color:#f92672>=</span> parMapN ma0 ma1 (,)
</span></span></code></pre></div><p>In Scala, there&rsquo;s also an instance for <code>IO</code> and <code>IO.Par</code>, a newtype that provides a different <code>Applicative</code> instance, which allows us to use functions such as <code>parMapN</code> with <code>IO</code> computations to run them in parallel!</p><p>And this is only the beginning&mldr; There are so many other useful functions we could define!</p><p>For now, the code is presented in <a href=https://github.com/gvolpe/types-matter>this Github repository</a> together with some other examples. Should there be enough interest, I might polish it and ship it as a library.</p><p>Let me know your thoughts!</p><p>Gabriel.</p></div><div class=related-posts><h3>Related Content</h3><div class=related-grid><div class=related-post><h4><a href=https://gvolpe.com/talks/medellin-2019/>Entering a Purely Functional World @ Scala MDE Meetup 2019 - Medellin, CO üá®üá¥</a></h4><div class=related-meta>2019.08.09 ‚Ä¢
‚òï 1 min read</div></div><div class=related-post><h4><a href=https://gvolpe.com/talks/tokyo-2020/>Haskell for Scala devs @ Tokyo Scala Meetup 2019 - Tokyo, JP üáØüáµ</a></h4><div class=related-meta>2019.02.01 ‚Ä¢
‚òï 1 min read</div></div><div class=related-post><h4><a href=https://gvolpe.com/talks/scala-love-2020/>Why Types Matter @ Scala Love 2020 - Online üåé</a></h4><div class=related-meta>2020.04.14 ‚Ä¢
‚òï 1 min read</div></div></div></div><nav class=post-navigation><div class=nav-previous><span class=nav-label>‚Üê Previous</span>
<a href=https://gvolpe.com/blog/setting-up-ghcide-nixpkgs-ubuntu/ class=nav-title>Setting up Ghcide in Ubuntu with Nixpkgs</a></div><div class=nav-next><span class=nav-label>Next ‚Üí</span>
<a href=https://gvolpe.com/blog/github-actions-nix-cachix-dhall/ class=nav-title>Github actions powered by Nix Shell & Cachix</a></div></nav></article></div></div></div></main><script src=https://gvolpe.com/js/main.js></script></body></html>
<!doctype html><html lang=en-us data-theme=light><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel=icon href=https://gvolpe.com/images/favicon.png><title>Lessons learned while writing a Haskell application - Gabriel Volpe</title><meta name=description content="Having introduced Haskell at my last job I wanted to put into practice all the stuff I learned: take the good, leave the bad. So I started working on an ‚Ä¶"><meta property="og:title" content="Lessons learned while writing a Haskell application"><meta property="og:description" content="Having introduced Haskell at my last job I wanted to put into practice all the stuff I learned: take the good, leave the bad. So I started working on an ‚Ä¶"><meta property="og:type" content="article"><meta property="og:url" content="https://gvolpe.com/blog/lessons-learned-while-writing-a-haskell-app/"><meta property="og:site_name" content="Gabriel Volpe"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="Lessons learned while writing a Haskell application"><meta name=twitter:description content="Having introduced Haskell at my last job I wanted to put into practice all the stuff I learned: take the good, leave the bad. So I started working on an ‚Ä¶"><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Orbitron:wght@400;700&family=JetBrains+Mono:wght@400;500&display=swap" rel=stylesheet><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css><link rel=stylesheet href=https://gvolpe.com/css/style.css></head><body><div class=reading-progress></div><main><div class="post-overlay active"><div class=post-overlay-backdrop></div><div class=post-overlay-content style=position:relative;min-height:100vh;padding:0;transform:translateY(0)><div class=post-overlay-header><div class=post-overlay-title><a href=/ class=overlay-site-title>Gabriel Volpe</a></div><button class=post-overlay-close aria-label="Close post" onclick='window.location.href="/"'>
<i class="fas fa-times"></i></button></div><div class=post-layout><article class=post-content><header class=post-header><div class=post-meta><span class=post-date>2019.06.23</span><div class=reading-time-post><span class=coffee-cups>üìöüìöüìöüìöüìö
</span><span>9 min read</span></div></div><h1 class=post-title>Lessons learned while writing a Haskell application</h1><div class=post-tags-header><a href=https://gvolpe.com/tags/haskell class=post-tag>haskell</a></div></header><div class=post-body><p>Having introduced Haskell at my last job I wanted to put into practice all the stuff I learned: take the good, leave the bad. So I started working on an <a href=https://github.com/gvolpe/exchange-rates>exchange rates API</a> using a few libraries I haven&rsquo;t used before, exclusively for fun and learning purposes.</p><p>In this blog post I&rsquo;ll try to share what I have identified as good practice so far and what are my personal
recommendations when writing a Haskell application.</p><style>.quote::before{content:"üí°"}</style><div class=quote><h4>Pro Tip</h4><p>If you write Scala, many of the tips will also be useful for you.</p></div><h3 id=configuration>Configuration</h3><p>I tried a couple of libraries where you must write your configuration file using either <code>yaml</code>, <code>hocon</code> or <code>json</code> but I wasn&rsquo;t satisfied until I&rsquo;ve been recommended to use <a href=https://dhall-lang.org/>dhall-lang</a>. It&rsquo;s a configuration language guaranteed to terminate that has also Haskell bindings, <a href=https://hackage.haskell.org/package/dhall>nicely packaged</a> for easy use. It looks as follows:</p><div class="highlight dhall-lang"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>Env</span> <span style=color:#f92672>=</span> <span style=color:#f92672>&lt;</span> <span style=color:#66d9ef>Test</span> <span style=color:#66d9ef>:</span> {} <span style=color:#f92672>|</span> <span style=color:#66d9ef>Prod</span> <span style=color:#66d9ef>:</span> {} <span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> makeConfig <span style=color:#f92672>=</span> Œª(env <span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Env</span>) <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>  { forex <span style=color:#f92672>=</span> makeForexConfig env
</span></span><span style=display:flex><span>  , redis <span style=color:#f92672>=</span> makeRedisConfig env
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>in</span> makeConfig ( <span style=color:#66d9ef>Env</span><span style=color:#f92672>.</span><span style=color:#66d9ef>Test</span> {<span style=color:#f92672>=</span>} )
</span></span></code></pre></div><p>Yes, it&rsquo;s a language so one can define functions! Neat huh?</p><h3 id=production-ready-effect-rio>Production-ready effect: RIO</h3><p>Ever since I read Michael Snoyman&rsquo;s articles <a href=https://www.fpcomplete.com/blog/2017/06/readert-design-pattern>The ReaderT design pattern</a> and <a href=https://www.fpcomplete.com/blog/2017/07/the-rio-monad>The RIO Monad</a> I&rsquo;ve been convinced that this
is the nicest and easiest approach to write applications.</p><p>Two years later after these articles have been published the package has evolved into what they call <a href=https://hackage.haskell.org/package/rio>RIO: A standard
library for Haskell</a>.</p><p>It doesn&rsquo;t only package <code>RIO</code>, its monadic effect, but also its own prelude. And in addition, it re-exports a bunch of other goodies such as error handling and lenses functions.</p><p>So right now this is my effect system of choice and it&rsquo;s the one you&rsquo;ll see in the examples below.</p><blockquote><p>It&rsquo;s worth mentioning other (higher-order) effects like <a href=https://github.com/fused-effects/fused-effects>fused-effects</a> and <a href=https://github.com/polysemy-research/polysemy>polysemy</a>, and also <a href=https://github.com/tweag/capability>capability</a>. I think we should all keep an eye on them as they look promising and propose a different take on effects.</p></blockquote><h3 id=polymorphic-record-of-functions>Polymorphic record of functions</h3><p>This is by far the best way I know of defining polymorphic interfaces.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#66d9ef>data</span> <span style=color:#66d9ef>Cache</span> m <span style=color:#f92672>=</span> <span style=color:#66d9ef>Cache</span>
</span></span><span style=display:flex><span>  { cacheNewResult <span style=color:#f92672>::</span> <span style=color:#66d9ef>Expiration</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Currency</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Currency</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Exchange</span> <span style=color:#f92672>-&gt;</span> m ()
</span></span><span style=display:flex><span>  , cachedExchange <span style=color:#f92672>::</span> <span style=color:#66d9ef>Currency</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Currency</span> <span style=color:#f92672>-&gt;</span> m (<span style=color:#66d9ef>Maybe</span> <span style=color:#66d9ef>Exchange</span>)
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#66d9ef>data</span> <span style=color:#66d9ef>Counter</span> m <span style=color:#f92672>=</span> <span style=color:#66d9ef>Counter</span>
</span></span><span style=display:flex><span>  { incrCount <span style=color:#f92672>::</span> m ()
</span></span><span style=display:flex><span>  , getCount <span style=color:#f92672>::</span> m <span style=color:#66d9ef>Int</span>
</span></span><span style=display:flex><span>  , resetCount <span style=color:#f92672>::</span> m ()
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><p>The advantage is that we can create different interpreters using different effect types. For example, the main implementation of <code>Cache m</code> uses <code>Redis</code> whereas the test one uses an in-memory map stored in an <code>IORef</code>.</p><h4 id=why-not-typeclasses>Why not typeclasses?</h4><p>Typeclasses are probably what come first when we think about polymorphic interfaces. However, they need laws / properties that define whether an instance is a valid one or not. Secondly, we can only define a single instance for a specific type. This is called coherence. If we can do that, great! If we fail then we would be better off using a record of functions instead.</p><p>To further defend this argument I should, perhaps, write another blog post only on this topic showing examples and expanding on the idea.</p><h3 id=smart-constructors>Smart constructors</h3><p>In order to create a specific record of functions it is recommended to hide its constructor and instead export a <em>smart constructor</em>. These are plain functions, normally effectful, responsible for the creation of a single interface. For convention, I chose to prefix them with <code>mk</code> (for make).</p><p>Here&rsquo;s how I defined the smart constructor for <code>Counter</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#a6e22e>mkCounter</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>IO</span> (<span style=color:#66d9ef>Counter</span> <span style=color:#66d9ef>IO</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>mkCounter</span> <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  (newIORef <span style=color:#ae81ff>0</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>IO</span> (<span style=color:#66d9ef>IORef</span> <span style=color:#66d9ef>Int</span>))
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;&amp;&gt;</span> (<span style=color:#a6e22e>\</span>ref <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Counter</span>
</span></span><span style=display:flex><span>          { incrCount  <span style=color:#f92672>=</span> void <span style=color:#f92672>$</span> atomicModifyIORef&#39; ref (<span style=color:#a6e22e>\</span>acc <span style=color:#f92672>-&gt;</span> (acc <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, acc))
</span></span><span style=display:flex><span>          , getCount   <span style=color:#f92672>=</span> readIORef ref
</span></span><span style=display:flex><span>          , resetCount <span style=color:#f92672>=</span> atomicWriteIORef ref <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>          }
</span></span><span style=display:flex><span>        )
</span></span></code></pre></div><p>Don&rsquo;t look so much at the implementation but more at its type signature. This pattern repeats over and over. We&rsquo;ll see soon how other smart constructors are defined.</p><h3 id=parametric-reasoning>Parametric reasoning</h3><p><code>RIO</code> is a concrete effect type, basically a newtype around <code>ReaderT</code> + <code>IO</code>, but it&rsquo;s also fully compatible with <code>mtl</code>
typeclasses. This means that we can write functions that use <code>RIO</code> directly and others that are 100% polymorphic. So&mldr;</p><h4 id=when-to-be-concrete-vs-when-to-be-polymorphic>When to be concrete vs When to be polymorphic?</h4><p>Here&rsquo;s my take: Be polymorphic where you have your main logic and be concrete when there&rsquo;s no logic to test. Let&rsquo;s look at an example to illustrate this statement better.</p><h4 id=to-be-concrete>To be concrete</h4><p>Here are the smart constructors for <code>Cache m</code> and <code>ForexClient m</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#a6e22e>mkRedisCache</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>HasRedisConfig</span> env <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>RIO</span> env (<span style=color:#66d9ef>Cache</span> <span style=color:#66d9ef>IO</span>)
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#a6e22e>mkForexClient</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>HasForexConfig</span> env <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>RIO</span> env (<span style=color:#66d9ef>ForexClient</span> <span style=color:#66d9ef>IO</span>)
</span></span></code></pre></div><p>For our main Cache (implemented using <a href=https://hackage.haskell.org/package/hedis>hedis</a>) and the Forex Client (http client using <a href=https://hackage.haskell.org/package/wreq>wreq</a>) I chose to be concrete, using <code>RIO</code> and the <code>Has</code> pattern.</p><p>Although this pattern is well described in the articles linked at the top, they don&rsquo;t cover polymorphic records of functions as is the case with <code>Ctx m</code>. So for a quick reference, here&rsquo;s the <code>HasCache</code> typeclass and its instance for our context.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#66d9ef>HasCache</span> ctx m <span style=color:#f92672>|</span> ctx <span style=color:#f92672>-&gt;</span> m <span style=color:#66d9ef>where</span>
</span></span><span style=display:flex><span>  cacheL <span style=color:#f92672>::</span> <span style=color:#66d9ef>Lens&#39;</span> ctx (<span style=color:#66d9ef>Cache</span> m)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>instance</span> <span style=color:#66d9ef>Monad</span> m <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>HasCache</span> (<span style=color:#66d9ef>Ctx</span> m) m <span style=color:#66d9ef>where</span>
</span></span><span style=display:flex><span>  cacheL <span style=color:#f92672>=</span> lens getCache (<span style=color:#a6e22e>\</span>x y <span style=color:#f92672>-&gt;</span> x { getCache <span style=color:#f92672>=</span> y })
</span></span></code></pre></div><p><strong>NOTE</strong>: you need to enable <code>FlexibleInstances</code>, <code>MultiParamTypeClasses</code> and <code>FunctionalDependencies</code>. Thanks to <a href=https://www.reddit.com/user/samb961/>/u/samb961</a> for helping me out with this!</p><p>In both cases they have no logic I&rsquo;m interested in testing so there&rsquo;s no motivation to abstract over the effect type.
What I want to test is how these components play their role in the main logic as we will see soon.</p><h4 id=to-be-polymorphic>To be polymorphic</h4><p>The main logic resides in the implementation of the <code>CachedForex</code> service. By following the flow diagram below you should be able to understand it.</p><p><img src=../../images/api-rates-flow.png alt=flow-diagram></p><p>For the atomic block <code>bracket</code> and <code>finally</code> from <code>Control.Monad.Catch</code> do the trick.</p><p>Now in order to create the service we need a couple of other components: <code>Logger m</code>, <code>Cache m</code>, <code>Counter m</code> and <code>ForexClient m</code>. We&rsquo;ve seen above the definition of a few of them and for brevity I&rsquo;ll skip others as they are quite similar.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#a6e22e>mkExchangeService</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>::</span> ( <span style=color:#66d9ef>MonadMask</span> m
</span></span><span style=display:flex><span>     , <span style=color:#66d9ef>HasLogger</span> ctx m
</span></span><span style=display:flex><span>     , <span style=color:#66d9ef>HasCache</span> ctx m
</span></span><span style=display:flex><span>     , <span style=color:#66d9ef>HasCounter</span> ctx m
</span></span><span style=display:flex><span>     , <span style=color:#66d9ef>HasForexClient</span> ctx m
</span></span><span style=display:flex><span>     , <span style=color:#66d9ef>MonadReader</span> ctx r
</span></span><span style=display:flex><span>     )
</span></span><span style=display:flex><span>  <span style=color:#f92672>=&gt;</span> r (<span style=color:#66d9ef>ExchangeService</span> m)
</span></span></code></pre></div><p>By making it polymorphic we get to choose our effect type and the dependencies needed while at the same type we apply <a href=https://blog.codinghorror.com/the-principle-of-least-power/>the principle of least power</a>. This gives us <em>parametric reasoning</em>. And it&rsquo;s perfect since we would like to test our logic without having a Redis instance running nor making real http requests to the external web service.</p><blockquote><p>One could argue that even if you make it concrete using <code>RIO</code> or <code>IO</code>, you can still pass different implementations, but we would be more limited to test using such effect and it&rsquo;ll be harder to reason about our function by just looking at its type signature.</p></blockquote><p><strong>Testing our main service</strong></p><p>In this case it ended up being more practical testing using <code>IO</code> + <code>IORef</code>, given the <code>MonadMask</code> constraint on <code>m</code>. But for demonstration purposes I wrote another version of the test suite using a <a href=https://github.com/gvolpe/exchange-rates/blob/master/test/Rates/CachedForexRST.hs>stack of monad
transformers</a> that doesn&rsquo;t use <code>IO</code>.</p><p>The testing approach I followed is to create different interpreters for the dependencies of the main service and then run some property tests on it. So we have an in-memory cache, a dummy Forex client that always returns the same response and a logger that doesn&rsquo;t log.</p><p>Finally, you need to choose a test library. I went with <a href=https://hackage.haskell.org/package/hedgehog>hedgehog</a>. Its documentation is quite nice and it&rsquo;s easy to get started with. Eg: below is the definition of the rates test.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#a6e22e>prop_get_rates</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Cache</span> <span style=color:#66d9ef>IO</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Property</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>prop_get_rates</span> cache <span style=color:#f92672>=</span> withTests <span style=color:#ae81ff>1000</span> <span style=color:#f92672>$</span> property <span style=color:#f92672>$</span> <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>  rph     <span style=color:#f92672>&lt;-</span> forAll <span style=color:#f92672>$</span> <span style=color:#66d9ef>Gen</span><span style=color:#f92672>.</span>int (<span style=color:#66d9ef>Range</span><span style=color:#f92672>.</span>linear <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>10</span>)
</span></span><span style=display:flex><span>  count   <span style=color:#f92672>&lt;-</span> forAll <span style=color:#f92672>$</span> <span style=color:#66d9ef>Gen</span><span style=color:#f92672>.</span>int (<span style=color:#66d9ef>Range</span><span style=color:#f92672>.</span>linear <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>10</span>)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> ctx <span style=color:#f92672>=</span> <span style=color:#66d9ef>Ctx</span> testLogger cache (mkTestCounter count) (mkTestForexClient rph)
</span></span><span style=display:flex><span>  service <span style=color:#f92672>&lt;-</span> evalIO <span style=color:#f92672>$</span> runRIO ctx mkExchangeService
</span></span><span style=display:flex><span>  from    <span style=color:#f92672>&lt;-</span> forAll <span style=color:#f92672>$</span> <span style=color:#66d9ef>Gen</span><span style=color:#f92672>.</span>element currencies
</span></span><span style=display:flex><span>  to      <span style=color:#f92672>&lt;-</span> forAll <span style=color:#f92672>$</span> <span style=color:#66d9ef>Gen</span><span style=color:#f92672>.</span>element currencies
</span></span><span style=display:flex><span>  cached  <span style=color:#f92672>&lt;-</span> evalIO <span style=color:#f92672>$</span> cachedExchange cache from to
</span></span><span style=display:flex><span>  evalIO (try (getRate service from to) <span style=color:#f92672>::</span> <span style=color:#66d9ef>TryRate</span>) <span style=color:#f92672>&gt;&gt;=</span> <span style=color:#a6e22e>\</span><span style=color:#66d9ef>case</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>Right</span> rs <span style=color:#f92672>-&gt;</span> rs <span style=color:#f92672>===</span> fromMaybe (<span style=color:#66d9ef>Exchange</span> <span style=color:#ae81ff>1.0</span>) cached
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>Left</span>  <span style=color:#66d9ef>_</span>  <span style=color:#f92672>-&gt;</span> assert (count <span style=color:#f92672>&gt;=</span> rph)
</span></span></code></pre></div><p>If we get a <code>Right rs</code> then we assert that the rate is equals to the one cached or the one returned by the forex
client. If we get a <code>Left e</code> instead that means that the API limit has been reached so we assert that the counter is greater or equals than the &ldquo;requests per hour&rdquo; value.</p><h4 id=web-server>Web server</h4><p>It wouldn&rsquo;t be fair if I didn&rsquo;t mention the web server. It is written using <a href=https://haskell-servant.readthedocs.io/en/stable/#>servant</a> and it&rsquo;s a pleasure to use. It also allows you to generate documentation from the API definition using <a href=https://swagger.io/>swagger</a>.</p><p>There are only two endpoints so there&rsquo;s not much to cover but in a nutshell, I decided to organize the code in three
different modules as shown below.</p><h4 id=endpoints>Endpoints</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#66d9ef>RatesAPI</span> <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>ApiVersion</span> <span style=color:#66d9ef>:&gt;</span> <span style=color:#e6db74>&#34;rates&#34;</span> <span style=color:#66d9ef>:&gt;</span> <span style=color:#66d9ef>QueryParam</span> <span style=color:#e6db74>&#34;from&#34;</span> <span style=color:#66d9ef>Currency</span> <span style=color:#66d9ef>:&gt;</span> <span style=color:#66d9ef>QueryParam</span> <span style=color:#e6db74>&#34;to&#34;</span> <span style=color:#66d9ef>Currency</span> <span style=color:#66d9ef>:&gt;</span> <span style=color:#66d9ef>Get</span> <span style=color:#66d9ef>&#39;[JSON]</span> <span style=color:#66d9ef>ExchangeResponse</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>:&lt;|&gt;</span> <span style=color:#66d9ef>ApiVersion</span> <span style=color:#66d9ef>:&gt;</span> <span style=color:#e6db74>&#34;currencies&#34;</span> <span style=color:#66d9ef>:&gt;</span> <span style=color:#66d9ef>Get</span> <span style=color:#66d9ef>&#39;[JSON]</span> [<span style=color:#66d9ef>Currency</span>]
</span></span></code></pre></div><p><em>Notice how the API is defined at the type level!</em></p><h4 id=response-handler>Response handler</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#a6e22e>rates</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>::</span> <span style=color:#66d9ef>ExchangeService</span> <span style=color:#66d9ef>IO</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Maybe</span> <span style=color:#66d9ef>Currency</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Maybe</span> <span style=color:#66d9ef>Currency</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Handler</span> <span style=color:#66d9ef>ExchangeResponse</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>rates</span> service (<span style=color:#66d9ef>Just</span> from) (<span style=color:#66d9ef>Just</span> to) <span style=color:#f92672>=</span> handle
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>\</span><span style=color:#66d9ef>ApiLimitReached</span> <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>    throwError <span style=color:#f92672>$</span> err503 { errBody <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Api limit has been reached&#34;</span> }
</span></span><span style=display:flex><span>  )
</span></span><span style=display:flex><span>  (liftIO <span style=color:#f92672>$</span> exchangeToResponse from to <span style=color:#f92672>&lt;$&gt;</span> getRate service from to)
</span></span><span style=display:flex><span><span style=color:#a6e22e>rates</span> <span style=color:#66d9ef>_</span> <span style=color:#66d9ef>_</span> <span style=color:#66d9ef>_</span> <span style=color:#f92672>=</span> throwError <span style=color:#f92672>$</span> err400 { errBody <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Invalid currencies&#34;</span> }
</span></span></code></pre></div><h4 id=data-and-json-instances>Data and json instances</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#66d9ef>data</span> <span style=color:#66d9ef>ExchangeResponse</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>ExchangeResponse</span>
</span></span><span style=display:flex><span>  { rate <span style=color:#f92672>::</span> <span style=color:#66d9ef>Float</span>
</span></span><span style=display:flex><span>  , from <span style=color:#f92672>::</span> <span style=color:#66d9ef>Currency</span>
</span></span><span style=display:flex><span>  , to <span style=color:#f92672>::</span> <span style=color:#66d9ef>Currency</span>
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>deriving</span> (<span style=color:#66d9ef>Generic</span>, <span style=color:#66d9ef>Show</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>instance</span> <span style=color:#66d9ef>ToJSON</span> <span style=color:#66d9ef>ExchangeResponse</span>
</span></span></code></pre></div><h3 id=conclusion>Conclusion</h3><p>These are some of the best practices I know of nowadays. But we all know this is a continuous learning process, it doesn&rsquo;t end here. Anyway, I hope you can get something out of it!</p><h4 id=summarizing>Summarizing:</h4><ul><li><em>Parametric reasoning matters</em>: ideally we should be able to tell what a function does by just looking at its type
signature.</li><li>Be concrete when there&rsquo;s no need to complicate things.</li><li>Polymorphic records of functions are neat.</li></ul><p>Have any thoughts or questions? Share it down in the comments!</p><p>Find the complete source code <a href=https://github.com/gvolpe/exchange-rates>here</a>.</p></div><div class=related-posts><h3>Related Content</h3><div class=related-grid><div class=related-post><h4><a href=https://gvolpe.com/talks/tokyo-2020/>Haskell for Scala devs @ Tokyo Scala Meetup 2019 - Tokyo, JP üáØüáµ</a></h4><div class=related-meta>2019.02.01 ‚Ä¢
‚òï 1 min read</div></div><div class=related-post><h4><a href=https://gvolpe.com/talks/eindhoven-2017/>Functional Data Validation @ Eindhoven Haskell Meetup 2017 - Eindhoven, NL üá≥üá±</a></h4><div class=related-meta>2017.06.01 ‚Ä¢
‚òï 1 min read</div></div></div></div><nav class=post-navigation><div class=nav-previous><span class=nav-label>‚Üê Previous</span>
<a href=https://gvolpe.com/blog/context-bound-vs-implicit-evidence/ class=nav-title>Context bound vs Implicit evidence: Performance</a></div><div class=nav-next><span class=nav-label>Next ‚Üí</span>
<a href=https://gvolpe.com/blog/functional-dependencies-and-type-families/ class=nav-title>Functional Dependencies & Type Families</a></div></nav></article></div></div></div></main><script src=https://gvolpe.com/js/main.js></script></body></html>